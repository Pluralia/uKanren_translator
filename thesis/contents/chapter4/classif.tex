\subsection{Классификации программ для трансляции и ограничения подхода}

В разделе описаны четыре классификации программ на \miniKanren{}.
Для каждой из классификаций указаны виды программ, не поддерживаемые транслятором.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{$In-Out$ классификация}

Программы на \miniKanren{}, отправляемые на трансляцию, можно разделить по направлениям трансляции.
Отсюда можно выделить следующие виды:
\begin{itemize}
    \item Все аргументы являются выходными;
    \item Все аргументы являются входными;
    \item Часть аргументов --- входные, часть --- выходные;
\end{itemize}

Транслятор не поддерживает только первый тип.
Он отклоняется процессе аннотирования вызова: раскрытия не происходит, если все аннотации его аргументов --- $Undef$, так как недостаточно информации для аннотирования.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Классификация для аннотатора}

В процесс разработки алгоритма аннотирования происходил итеративно.
На первой итерации был разработан алгоритм для нормализованных программ на \miniKanren{}.
На последующих --- постепенно добавлялись оставшиеся конструкции \miniKanren{} и свойства.
Естественно произвести классификацию программ в соответствии с использованием тех или иных конструкций и свойств.
Одна и та же программа может содержать разные конструкции, и, как следствие, находиться одновременно в нескольких классах.

\begin{itemize}
    \item Тело отношения находится в ДНФ;
    \item $fresh$-переменные только на верхнем уровне;
    \item Присутствуют унификации двух конструкторов;
    \item Ни в каком дизъюнкте нет вызовов (только унификации);
    \item В каждом дизъюнкте не более одного вызова на аргументах-переменных;
    \item Несколько вызовов на аргументах-переменных;
    \item Унификация $fresh$-переменных только друг с другом;
    \item Нерекурсивные вызовы на аргументах-конструкторах;
    \item Рекурсивные вызовы на аргументах-конструкторах;
    \item Вызовы на одних и тех же переменных;
\end{itemize}

Все перечисленные виды поддерживаются.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Классификация по особенностям \miniKanren{}}

Как в классификации для аннотатора, программа принадлежит конкретному классу, если содержит соответствующую конструкцию или отвечает определённому свойству.
В отличие от классификации для аннотатора, данная классификация принимает во внимание не только саму программу на \miniKanren{}, но и текущее направление трансляции.
Направление вычисления влияет на проявление особенностей.
Например, при одном направлении перекрытие дизъюнктов не сможет произойти, так как каждый дизъюнкт рассматривает один из конструкторов входной переменной.
Поменяв направление, получим другой набор входных переменных, для которых соответствующих унификаций, перебирающих конструкторы, может уже не быть.

\begin{itemize}
    \item Несколько выходных переменных;
    \item Перекрытие в результатов дизъюнктов;
    \item Недетерминированность результатов;
    \item Унификация $fresh$-переменных только друг с другом;
\end{itemize}


Все перечисленные виды поддерживаются.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Классификация для транслятора}

Перечисляет проблемы, возникающие при трансляции.
Каждая проблема разрешается добавлением в итоговую программу новой конструкции.
Таким образом, эта классификация также распределяет транслированные программы по наличию тех или иных конструкций.
Одна программа может принадлежать нескольким классам.

\begin{itemize}
    \item Перекрытие имён в сопоставлениях с образцом (охранные выражения);
    \item Перекрытие имён в определениях (условие для ветвления);
    \item Конструкторы и генерация (запрашивается у пользователя);
    \item Несколько выходных переменных при вызове (возврат результата в кортеже);
    \item Определение возникло из унификации (выражение вида $let~x~=~y$);
    \item Определение возникло из вызова (выражение вида $x \leftarrow func~y$);
\end{itemize}

Классификация не содержит проблемы, которые привели к постоянному использованию определённых конструкций.
Пример --- проблема перекрытия результатов дизъюнктов, так как теперь каждая функция является конкатенацией результатов вспомогательных функций.

Все перечисленные виды поддерживаются.
