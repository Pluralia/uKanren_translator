\subsection{Нормализация программ для аннотирования}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Нерекурсивные вызовы на конструкторах}

К моменту вызова аргумент-конструктор может быть проаннотирован частично.
В этом случае неизвестно является ли переменная, соответствующая данному аргументу, входной или выходной.
Другими словами, невозможно определить направление вызова.

Для решения данной проблемы будем действовать следующим образом:
\begin{itemize}
    \item Сформируем новое отношение, принимающее на вход все переменные аргументов вызова. Его тело --- тело вызываемого отношения с подставленными в него аргументами.
    \item Вызов старого отношения на аргументах-конструкторах заменим на вызов нового отношения на аргументах-переменных. 
\end{itemize}

Рассмотрим вызов $append^o~(a : as)~ys~z$.
Один из его аргументов --- конструктор списка.
Сформируем новое отношение $append^o1$ (см. рисунок ~\ref{lst:appendo1}), осуществив подстановку $x~\rightarrow~(a~:~as)$ в тело $append^o$.
Заметим, что первый дизъюнкт $append^o$ отсутствует в $append^o1$.
Он стал заведомо ошибочен: унификация $x \equiv []$ обратилась в $(a : as) \equiv []$.
Во втором дизъюнкте первый конъюнкт обратился в унификацию двух конструкторов и, как следствие, разбился на две унификации.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=41, escapechar=|]
  $append^o1$ $a$ $as$ $y$ $z$ =
    (fresh [h, t, r] (
        a $\equiv$ h $\wedge$ |\label{line:appendo13}|
        as $\equiv$ t $\wedge$ |\label{line:appendo14}|
        z $\equiv$ h : r $\wedge$ |\label{line:appendo15}|
        $append^o$ t y r |\label{line:appendo16}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Отнощение $append^o1$, полученное подстановкой $x~\rightarrow~(a~:~as)$ в $append^o$}
  \label{lst:appendo1}
\end{figure}

Производить замену вызова на аргументах-конструкторах нужно также в теле созданного отношения, поэтому данный алгоритм должен запускаться до достижения неподвижной точки.
В связи с этим алгоритм может зацикливаться при работе с рекурсивными вызовами на конструкторах.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Рекурсивные вызовы на конструкторах}

Рассмотрим проблему на примере.
Отношение $revacc^o$ связывает три списка: третий получается переворачиванием первого, а второй является аккумулятором.
$revacc^o$ приведено на рисунке~\ref{lst:revacco}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=48, escapechar=|]
  $revacc^o$ $xs$ $acc$ $sx$ =
    ($xs$ $\equiv$ [] $\wedge$ $sx$ $\equiv$ $acc$) $\vee$ |\label{line:revacco2}|
    (fresh [h, t] (
        $xs$ $\equiv$ $h$ : $t$ $\wedge$ |\label{line:revacco4}|
        $revacc^o$ $t$ $(h~\%~acc)$ $sx$ |\label{line:revacco5}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Отношение $revacc^o$}
  \label{lst:revacco}
\end{figure}

Данное отношение содержит рекурсивный вызов на конструкторе в строке~\ref{line:revacco5}.
Попробуем заменить его на новое отношение по алгоритму, описанному в предыдущей секции.
Подстановка $aсс~\rightarrow~(h~:~acc)$ в $revacc^o$ представлена на рисунке~\ref{lst:revacco1}.
На данном рисунке видно, что в строке~\ref{line:revacco15} такая подстановка привела к большей вложенности конструкторов.
Это означает, что неподвижная точка не будет достигнута никогда.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=48, escapechar=|]
  $revacc^o1$ $xs$ $h$ $acc$ $sx$ =
    ($xs$ $\equiv$ [] $\wedge$ $sx$ $\equiv$ $(h~\%~acc)$) $\vee$ |\label{line:revacco12}|
    (fresh [h', t] (
        $xs$ $\equiv$ $h'$ : $t$ $\wedge$ |\label{line:revacco14}|
        $revacc^o$ $t$ $(h'~\%~(h~\%~acc))$ $sx$ |\label{line:revacco15}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Отношение $revacc^o1$, полученное подстановкой $acc~\rightarrow~(h~:~acc)$ в $revacc^o$}
  \label{lst:revacco1}
\end{figure}

Альтернативное решение состоит из двух шагов:
\begin{itemize}
    \item В дизъюнкт, содержащий рекурсивный вызов на конструкторе, добавим конъюнкт --- унификацию этого конструктора с новой переменной;
    \item В вызове аргумент-конструктор заменим на новую переменную.
\end{itemize}

На рисунке~\ref{lst:revacco2IOOANN} приведён пример применения данного решения и результат аннотирования $revacc^o$ в прямом направлении.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=48, escapechar=|]
  $revacc^o2$ $xs0$ $acc1$ $sx1$ =
    ($xs0$ $\equiv$ [] $\wedge$
    $sx1$ $\equiv$ $<gen:>$ $\wedge$|\label{line:revacco2IOOANN2}|
    $sx1$ $\equiv$ $acc2$) $\vee$ |\label{line:revacco2IOOANN3}|
    (fresh [h, t, hacc] (
        $xs0$ $\equiv$ $h1$ : $t1$ $\wedge$ |\label{line:revacco2IOOANN5}|
        $hacc2$ $\equiv$ $h1$ : $acc3$ $\wedge$ |\label{line:revacco2IOOANN6}|
        $revacc^o$ $t1$ $hacc2$ $sx2$ |\label{line:revacco2IOOANN7}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат аннтирования отношения $revacc^o2$, полученного унификацией аргумента-конструктора с первым входным аргументом}
  \label{lst:revacco2IOOANN}
\end{figure}

Унификация позволит определять к моменту вызова, является ли аргумент, бывший конструктором, входным или выходным.
``Минусом'' данного подхода является возможность потерять информацию об аннотациях переменных конструктора для аннотирования тела вызова.
Потеря этой информации может привести к неуспешному завершению аннотирования.
Применение алгоритма генерация способно исправить ситуацию.

Данный подход может работать и для нерекурсивных вызовов на конструкторах, но он с большей вероятностью потребует генерацию, применения которой хочется избежать.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Вызовы на одних и тех же переменных}

Вызовы отношений могут происходить на одних и тех же переменных.
В этом случае аннотации соответствующих аргументов обязаны совпадать.
Это делает не валидными некоторые направления, которые, судя по количеству аргументов, должны существовать.

Рассмотрим пример: $append^o~x~x~z$.
У $append^o$ три аргумента и, значит, восемь направлений.
Однако, первые два аргумента данного вызова совпадают и направлений остаётся четыре, так как направления с разной аннотацией первых двух аргументов становятся невалидными.

Справиться с данной проблемой помогает тот же подход, что и для нерекурсивных вызовах на конструкторах: создадим новое отношение, подставив аргументы в тело исходного.
В созданном отношении (см. рисунок~\ref{lst:appendo2}) заведомо не может существовать невалидных направлений.
\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=57, escapechar=|]
  $append^o2$ x z =
    (x $\equiv$ [] $\wedge$ x $\equiv$ z) $\vee$ |\label{line:appendo22}|
    (fresh [h, t, r] (
        x $\equiv$ h : t $\wedge$ |\label{line:appendo24}|
        z $\equiv$ h : r $\wedge$ |\label{line:appendo25}|
        $append^o$ t x r |\label{line:appendo26}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{$append^o2$, полученное подстановкой $y~\rightarrow~x$ в $append^o$}
  \label{lst:appendo2}
\end{figure}
