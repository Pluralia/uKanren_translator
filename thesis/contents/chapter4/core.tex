\subsection{Алгоритм аннотирования нормализованной программы}

Алгоритм аннотирования получает на вход нормализованную программу на \miniKanren{} (цель и список определений), а также список входных переменных.
По окончанию его работы будет получен список проаннотированных определений, требуемых для вычисления цели.
Мы будем называть этот список \emph{стеком вызовов}, потому что в нем будут находиться вызываемые отношения.

\emph{Успешным результатом аннотирования} назовём ситуацию, когда получившийся по окончании выполнения алгоритм стек вызовов удовлетворяет следующим условиям:
\begin{itemize}
    \item Все отношения, требуемые для вычисления цели программы, присутствуют в стеке;
    \item Все переменные отношений, присутствующих в стеке вызовов, проаннотированы числом;
\end{itemize}

При инициализации алгоритма выполняются следующие действия: 
\begin{itemize}
    \item Все входные переменные аннотируются $0$;
    \item Создается пустой стек вызовов;
\end{itemize}

Аннотация цели осуществляется итеративно, пока не будет достигнута неподвижная точка функции, описывающей шаг аннотирования. 
За один шаг аннотируется хотя бы одна унификация или один вызов отношения.
Если в течение шага ни одна новая переменная не была проаннотирована, считается, что достигнута неподвижная точка.
Для аннотации цели в дищъюнктивной нормальной форме необходимо проаннотировать все её дизъюнкты. 
Аннотации переменных в дизъюнкте должны согласовываться: одна и та же переменная в конъюнктах одного дизъюнкта должна иметь одну и ту же аннотацию.
Конъюнкты аннотируются в заранее определенном порядке. 
Сначала мы аннотируем унификации, а затем вызовы отношений. 
Каждый раз при аннотации новой переменной необходимо установить ту же аннотацию всем другим вхождениям этой переменной в дизъюнкте. 

При аннотировании унификаций возможны следующие случаи. 
Здесь и далее аннотация переменной указывается в верхнем индексе.
\begin{itemize}
    \item Унификация имеет вид $x^{Undef} \equiv t[y_0^{i_0}, \dots, y_k^{i_k}]$, то есть переменная, имеющая аннотацию $Undef$, унифицируется с термом $t$ со свободными переменными $y_j^{i_j}$ с целочисленными аннотациями $i_j$. В таком случае переменной $x$ необходимо присвоить аннотацию $n + 1$, где $n = max \{ i_0, \dots i_k\}$;
    \item Переменная, аннотированная числом, унифицируется с термом: $x^{n} \equiv t[y_0^{i_0}, \dots, y_k^{i_k}]$; некоторые свободные переменные терма проаннотированны $Undef$.
    Тогда всем переменным $y_j^{Undef}$ присваивается аннотация $n+1$;
    \item Остальные случаи симметричны;
\end{itemize}

Помимо унификации конъюнкт может быть вызовом некоторого отношения.
Если переменные всех аргументов проаннотированы $Undef$, для аннотирования не достаточно информации, поэтому следует перейти к аннотации следующего конъюнкта.
Если хотя бы одна переменная-аргумент не $Undef$, произведём аннотацию вызова.
Она состоит из двух частей: аннотации аргументов самого вызова и, в случае необходимости, аннотации тела вызываемого отношения в соответствии с направлением вызова.

Aннотация тела вызываемого отношения состоит из следующих шагов:
\begin{itemize}
    \item Получение направление вызова. Для этого аннотации аргументов ``сбрасываются'': $Undef$ остаются таковыми, а числовые --- становятся $0$. Для вызываемого отношения не важен момент времени в прошлом, когда его входные переменные стали известны --- для него они все стали известны в момент времени $0$;
    \item Аргументы вызова подставляются вместе со ``сброшенными'' аннотациями в тело вызываемого отношения;
    \item Имя, направление вызова и частично проаннотированное тело помещаются в стек вызовов;
    \item Происходит запуск алгоритма аннотирования;
    \item Обновляется стек вызовов: по имени и направлению помещается тело вызова после аннотирования;
\end{itemize}

Добавление в стек вызовов информации о ранее проаннотированных в конкретных направлениях отношениях позволяет избежать повторного аннотирования.
В частности, помогает не получить бесконечный цикл при аннотировании рекурсивного вызова.
Как это происходит: если частично определенное направление текущего вызова согласовано с ранее проаннотированным, анализировать его не нужно.
Два направления назовем \emph{согласованными}, если:
\begin{itemize}
    \item Аннотации их аргументов попарно совпадают;
    \item Некоторые аннотации аргументов одного из направлений являются $Undef$, а оставшиеся, числовые, совпадают с соответствующими числами аннотаций аргументов другого направления;
\end{itemize}

Для иллюстрации понятия согласованных направлений рассмотрим следующие примеры:
\begin{itemize}
    \item Пусть есть отношение $r^o$ с частично определенными направлениями: $r^o \ x^0 \ y^0 \ z^{Undef}$ и $r^o \ x^1 \ y^0 \ z^{Undef}$;
        Они являются несогласованными, так как аннотации переменной $x$ являются числовыми и не совпадают.
    \item Направление $r^o \ x^1 \ y^0 \ z^{Undef}$ согласовано с направлением $r^o \ x^1 \ y^0 \ z^1$, так как аннотация $z$ в первом направлении является $Undef$ и, значит, может оказаться как входной, так и выходной.
\end{itemize}

Перейдём к аннотации аргументов самого вызова.
Первым шагом нужно определить, есть ли необходимость аннотировать тело вызова.
По имени и направлению проверяем наличие согласованного направления в стеке вызовов.
Если такового не оказалось, запустим аннотацию тела вызываемого отношения, а иначе сразу перейдём к аннотации аргументов.
Для этого необходимо заменить $Undef$-аннотации переменных на $n+1$, где $n$ --- максимальная аннотация переменных-аргументов вызова.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Существуют отношения, точная аннотация которых не возможна без полного перебора возникающих вариантов. 
Один из видов таких отношений --- отношения, содержащие несколько вызовов в одном дизъюнкте
Пример такого отношения приведен на рисунке~\ref{lst:reloDEF}.
Пусть $y$ --- входная переменная.
В этом случае порядок вычисления вызовов $f^o$ и $h^o$ не зависит друг от друга, но зависит от направления вычисления $g^o$.
Оно не может вычисляться до вычисления $f^o$ и $h^o$ (неизвестны входные переменные), но может вычисляться между ними (в прямом или обратном порядке) или после (выполнять роль предиката).

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.18\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=22, escapechar=|]
  $rel^o$ x y z =
    $f^o$ x y $\vee$
    $h^o$ z y $\vee$
    $g^o$ x z
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Пример программы на \miniKanren{} с несколькими вызовами в одном дизъюнкте}
  \label{lst:reloDEF}
\end{figure}

Рассмотрим конкретный пример.
Возьмём то же определение $revers^o$, что было рассмотрено на рисунке~\ref{lst:reversoOIANN}, и попробуем проаннотировать его в прямом направлении (см. рисунок~\ref{lst:reversoIOANNfail}).

Во втором дизъюнкте определим аннотации переменных $h$ и $t$ в строке~\ref{line:reversoIOANNfail4} и распространим их на последующие вызовы.
Зная, что только второй аргумент входной, попытаемся проаннотировать тело $append^o$ (см. рисунок~\ref{lst:appendoOIOANNfail}).
Оно завершится неудачией: строках~\ref{line:appendoOIOANNfail4} и~\ref{line:appendoOIOANNfail4} остались переменные, проаннотированные $Undef$.
Причина в том, что при таком направлении не существует возможности узнать значения (а, значит, и время связывания) переменных $h$, $x$ и $z$ (данная проблема обсуждается в следующем подразделе).
Мы можем успешно завершить аннотирование $revers^o$, однако, при трансляции не сможем получить работающую программу, так как не успешно завершилось аннотирование $append^o$. 

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=26, escapechar=|]
  $revers^o$ $x^0$ $y^1$ =
    ($x^0$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ []) $\vee$ |\label{line:reversoIOANNfail2}|
    (fresh [h, t, r] (
        $x^0$ $\equiv$ $h^1$ : $t^1$ $\wedge$ |\label{line:reversoIOANNfail4}|
        $append^o$ $r^{2}$ $[h^1]$ $y^{2}$ |\label{line:reversoIOANNfail5}|
        $revers^o$ $t^1$ $r^{2}$ $\wedge$ |\label{line:reversoIOANNfail6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат аннотирования отношения $revers^o$ в прямом направлении с порядком вызовов $append^o$-$revers^o$}
  \label{lst:reversoIOANNfail}
\end{figure}

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.5\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=33, escapechar=|]
  $append^o$ $x^1$ $y^0$ $z^1$ =
    ($x^1$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ $z^0$) $\vee$ |\label{line:appendoOIOANN2}|
    (fresh [h, t, r] (
        $x^{Undef}$ $\equiv$ $h^{Undef}$ : $t^1$ $\wedge$ |\label{line:appendoOIOANNfail4}|
        $z^{Undef}$ $\equiv$ $h^{Undef}$ : $r^1$ $\wedge$ |\label{line:appendoOIOANNfail5}|
        $append^o$ $t^1$ $y^0$ $r^1$ |\label{line:appendoOIOANNfail6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат аннотирования отношения $append^o \ ? \ y \ ?$}
  \label{lst:appendoOIOANNfail}
\end{figure}

Посмотрим, как будет происходить аннотирование, если поменять местами вызовы $append^o$ и $revers^o$~\ref{lst:reversoIOANN}.
Строка~\ref{line:reversoIOANN5} содержит рекурсивный вызов того же направления, что и исходное отношение --- так становится известна переменная $r$.
Аннотирование будет успешно завершено аннотированием вызова $append^o$ в обратном направлении (см. рисунок~\ref{lst:appendoOOIANN}) в строке~\ref{line:reversoIOANN6}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=40, escapechar=|]
  $revers^o$ $x^0$ $y^1$ =
    ($x^0$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ []) $\vee$ |\label{line:reversoIOANN2}|
    (fresh [h, t, r] (
        $x^0$ $\equiv$ $h^1$ : $t^1$ $\wedge$ |\label{line:reversoIOANN4}|
        $revers^o$ $t^4$ $r^3$ $\wedge$ |\label{line:reversoIOANN5}|
        $append^o$ $r^3$ $[h^2]$ $y^0$ |\label{line:reversoIOANN6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат аннотирования отношения $revers^o$ в прямом направлении с порядком вызовов $revers^o$-$append^o$}
  \label{lst:reversoIOANN}
\end{figure}

Для решения проблемы нескольких вызовов в одном дизъюнкте предложено решение с перестановками конъюнктов.
Если в аннотируемом отношении в одном дизъюнкте найдено несколько вызовов, создаётся несколько версий этого дизъюнкта.
Каждая версия отличается очередной перестановкой вызовов.
Далее происходит запуск аннотирования дизъюнкта на каждой из версий до тех пор, пока либо аннотирование закончится успехом, либо будут просмотрены все возможные версии.
В последнем случае считается, что аннотирование не успешно.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Причина, по которой невозможно проаннотировать $append^o \ ? \ y \ ?$ (см. рисунок~\ref{lst:appendoOIOANNfail}) --- $fresh$-переменные, которые зависят только друг от друга.
В данном примере это переменные $h$, $x$ и $z$.
$h$ встречается в двух унификациях, но проаннотировать её невозможно.
В строке~\ref{line:appendoOIOANNfail4} она унифицируется с переменной $x$, а в строке~\ref{line:appendoOIOANNfail5} --- с переменной $z$.
$x$, и $z$ являются выходными (fresh-переменными) и их значения остаются неизвестными, так как они не присутствуют в последнем конъюнкте (строка~\ref{line:appendoOIOANNfail6}).

Таким образом, не существует возможности проаннотировать $fresh$-переменные, зависящие друг от друга, так как они никогда не станут известны --- остаются свободными.
В \miniKanren{} такие переменные могут принимать все допустимые значения.
Мы можем сымитировать данный подход, добавив генерацию переменных оставшихся свободными.
Под \emph{добавлением генерации} понимается добавление в дизъюнкт нового конъюнкта --- унификации целевой переменной со специальным термом-конструктором вида $C~"gen"~[]$ (в конкретном синтаксисе $<gen:>$).
В этом случае аннотация такой переменной будет являться аннотацией константы и равняться $1$.

Рассмотрим полный алгоритм добавления генерации.
Прежде всего, необходимо произвести аннотирование отношения без генерации по вышеописанному алгоритму, чтобы выяснить, какие переменные не получилось проаннотировать.
Если полученный после аннотирования стек содержит частично проаннотированные определения, проанализируем каждое из них.
Рассмотрим каждую унификацию.
Если она содержит непроаннотированные переменные, то содержит их в обеих частях.
Нет смысла генерировать переменные обеих частей: переменные одной части станут известны, если станут известны переменные другой.
Поймём, какая из частей унификации является более частным случаем и будем генерировать переменные именно этой части.

Посмотрим, как по двум термам определить, является ли первый из них частным случаем второго.
Алгоритм проинициализируем пустой подстановкой --- списком пар переменная-терм.
Если первый терм является частным случаем второго, то результатом алгоритма будет подстановка соответствующих подтермов второго терма вместо переменных первого терма.
Возможным следующие варианты:
\begin{itemize}
    \item Первый терм --- переменная $v$, второй --- терм $u$ (может быть и переменной, и конструктором).
    По переменной $v$ попробуем получить терм подстановки.
    Если это удалось сделать, сравним полученный терм с $u$ --- в случае совпадения вернём текущую подстановку, иначе искомой подстановки не существует и первый подтерм не является подтермом второго.
    Если $v$ в подстановке не нашлось, добавим в неё пару $(v,~u)$.
    \item Случая двух конструкторов нет для нормализованной программы нет.
    \item В оставшихся случаях искомой подстановки заведомо не существует.
\end{itemize}

После добавления генерации необходимо запустить алгоритм аннотирования ещё раз, чтобы проаннотировать сгенерированные переменные и распространить их аннотации на всё отношение.
Шаг "генерация-аннотация" нужно повторять до достижения неподвижной точки: после генерации при повторном аннотировании может появиться возможность проаннотировать вызов, который до этого был на полностью неопределённых переменных.
Для аннотирования тела этого вызова так же может потребоваться генерация.
Аннотирование $append^o \ ? \ y \ ?$ с добавлением генерации приведено на рисунке~\ref{lst:appendoOIOANN}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=33, escapechar=|]
  $append^o$ $x^1$ $y^0$ $z^1$ =
    ($x^1$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ $z^0$) $\vee$ |\label{line:appendoOIOANN2}|
    (fresh [h, t, r] (
        $h^1$ $\equiv$ $<gen:>$ $\wedge$ |\label{line:appendoOIOANN4}|
        $x^2$ $\equiv$ $h^1$ : $t^1$ $\wedge$ |\label{line:appendoOIOANN5}|
        $z^2$ $\equiv$ $h^1$ : $r^1$ $\wedge$ |\label{line:appendoOIOANN6}|
        $append^o$ $t^1$ $y^0$ $r^1$ |\label{line:appendoOIOANN7}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат аннотирования отношения $append^o \ ? \ y \ ?$ c добавлением генерации}
  \label{lst:appendoOIOANN}
\end{figure}

Генерация позволила проаннотировать $append^o \ ? \ y \ ?$. 
В этом случае аннотирование $revers^o$ с последовательностью вызовов $append^o$-$revers^o$ (рисунок~\ref{lst:reversoIOANNfail}) становится успешным.
Это даёт два способа трансляции $revers^o$ в прямом направлении.
Так, для примера на рисунке~\ref{lst:reversoIOANNfail} из вызовов будут сгенерированны две функции: предикат $revers^o$ и $append^o \ ? \ y \ ?$.
Для отношения на рисунке~\ref{lst:reversoIOANN}) --- только $append^o$ в обратном направлении.

Генерация переменных способна влиять на направления вычислений конъюнктов, поэтому её стоит применять только по необходимости.
Чтобы нивелировать это влияние, будем генерировать переменные только в случае не успешного аннотирования.
Для этого запустим алгоритм генерации после запуска алгоритма перебора перестановок конъюнктов.
На примере $revers^o$: из двух вариантов предпочтительной последовательностью конъюнктов обладает вариант на рисунке~\ref{lst:reversoIOANN} --- $revers^o$ с последовательностью вызовов $revers^o$-$append^o$.
Аннотирование второго дизъюнкта на рисунке~\ref{lst:reversoIOANNfail} завершится неудачей, поэтому произойдёт перестановка вызовов и получим последовательность конъюнктов другого варианта.
Это приведёт к успеху аннотирования и генерация не понадобится.
