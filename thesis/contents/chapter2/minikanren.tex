\subsection{Язык программирования \miniKanren{}}

Семейство языков \miniKanren{} дало рождение парадигме реляционного программирования. 
Это минималистичные языки, встраиваемые в языки программирования общего назначения. 
Как и \prolog{} они обладают свойством \emph{полимодальности} --- возможностью вычисляться в различных направлениях.
Помимо простоты использования при разработке конечных приложений, \miniKanren{} реализует полный поиск: все существующие решения будут найдены, пусть и за длительное время.
Классический представитель родственной парадигмы логического программирования \prolog{} этим свойством не обладает: исполнение программы может не завершиться, даже если не все решения были вычислены. 
Незавершаемость программ на \prolog{} --- свойство стратегии поиска решения.
Для устранения потенциальной нетерминируемости используются нереляционные конструкции, такие как cut. 
Эта особенность существенно усложняет и часто делает невозможным исполнение в обратном направлении. 
Язык \miniKanren{} же является чистым\footnote{Технически это неправда: в \miniKanren{} есть дополнительные конструкции, которые не являются реляционными. Однако, Ядро (или \microKanren{}), при этом, чистое. В данной работе рассматривается только чистое подмножество.}: все языковые конструкции обратимы.

Программа на \miniKanren{} состоит из набора определений отношений и цели. 
Определение имеет имя, список аргументов и тело.
Тело отношения является \textit{целью}, которая может содержать \textit{унификацию термов} и \textit{вызовы отношений}, скомбинированные при помощи \textit{дизъюнкций} и \textit{конъюнкций}. 
\textit{Терм} представляет собой или \textit{переменную}, или \textit{конструктор} с именем и списком подтермов. 
Свободные переменные вводятся в область видимости при помощи конструкции $\underline{fresh}$. 
Абстрактный синтаксис языка приведен ниже:
\begin{align*}
  Goal &: Goal \vee Goal \ \ \ \ \ \ \ \ \ \ (disjunction) \\
       &\mid Goal \wedge Goal \ \ \ \ \ \ \ \ \ \ (conjunction) \\
       &\mid Term \equiv Term \ \ \ \ \ \ \ (unification) \\
       &\mid \underline{call} \ Name \ [Term] \\
       &\mid \underline{fresh} \ [Var] \ Goal \\
  Term &: Var \\ 
       &\mid \underline{cons} \ Name \ [Term]
\end{align*}

Пример программы на языке \miniKanren{}, связывающей три списка, где третий является конкатенацией первых двух, приведен на рисунке~\ref{lst:appendo}. 
Для краткости $[]$ заменяет пустой список ($\underline{cons} \ Nil \ []$); $h : t$ обозначает список с головой $h$ и хвостом $t$ ($\underline{cons} \ Cons \ [h, t]$), а $[x_0, x_1, \dots, x_n]$ --- список с элементами $x_0, x_1, \dots, x_n$. 
Вызов отношения $\underline{call} \ relation \ [t_0, \dots t_k]$ записывается как $relation \ t_0 \dots \ t_k$.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.5\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $append^o$ x y z =
    (x $\equiv$ [] $\wedge$ y $\equiv$ z) $\vee$ |\label{line:appendo2}|
    (fresh [h, t, r] (
        x $\equiv$ h : t $\wedge$                |\label{line:appendo4}|
        z $\equiv$ h : r $\wedge$                |\label{line:appendo5}|
        $append^o$ t y r                         |\label{line:appendo6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Пример программы на \miniKanren{}}
  \label{lst:appendo}
\end{figure}

Исполнение этого отношения в прямом направлении на двух заданных списках $append^o \ [1,2] \ [3] \ ?$ вернёт их конкатенацию $[1,2,3]$.
Если исполнить его в обратном направлении, оставив первые два аргумента неизвестными, мы получим все возможные разбиения данного списка на два: результатом $append^o \ ? \ ? \ [1,2,3]$ является множество пар $\{([],[1,2,3]), ([1], [2,3]), ([1,2], [3]), ([1,2,3], [])\}$.
Стоит заметить, что \miniKanren{} не всегда перечисляет все результаты, а иногда использует метапеременные.
