\subsection{Расширение множества аннотируемых программ}

Каждая часть данного раздела описывает способ расширения множества программ, которые возможно проаннотировать и, в дальнейшем, транслировать.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Нескольких вызовов в одном дизъюнкте}

Существуют отношения, точная аннотация которых не возможна без вмешательства человека или полного перебора возникающих вариантов. 
Один из видов таких отношений --- отношения, содержащие несколько вызовов в одном дизъюнкте
Пример такого отношения приведен на рисунке~\ref{lst:reloDEF}.
Пусть $y$ --- входная переменная.
В этом случае порядок вычисления вызовов $f^o$ и $h^o$ не зависит друг от друга, но зависит от направления вычисления $g^o$.
Оно не может вычисляться до вычисления $f^o$ и $h^o$ (неизвестны входные переменные), но может вычисляться между ними (в прямом или обратном порядке) или после (выполнять роль предиката).

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.18\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=22, escapechar=|]
  $rel^o$ x y z =
    $f^o$ x y $\vee$
    $h^o$ z y $\vee$
    $g^o$ x z
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Пример программы на \miniKanren{} с несколькими вызовами в одном дизъюнкте}
  \label{lst:reloDEF}
\end{figure}

Рассмотрим конкретный пример.
Возьмём то же определение $revers^o$, что было рассмотрено на рисунке~\ref{lst:reversoOIANN}, и попробуем проаннотировать его в прямом направлении (см. рисунок~\ref{lst:reversoIOANNfail}.

Во втором дизъюнкте определим аннотации переменных $h$ и $t$ в строке~\ref{line:reversoIOANNfail4} и распространим их на последующие вызовы.
Далее попытаемся проаннотировать тело $append^o$ с учётом, что только второй аргумент входной.
Как показано на рисунке~\ref{lst:appendoOIOANNfail}, попытка этого потерпит неудачу.
Во втором дизъюнкте $append^o$ при таком направлении не существует возможности узнать значение (а, значит, и время связывания) переменных $h$, $x$ и $z$ (данная проблема обсуждается в следующей подчасти).
Мы можем успешно завершить аннотирование $revers^o$, однако, при трансляции не сможем получить работающую программу, так как не успешно завершилось аннотирование $append^o$. 

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=26, escapechar=|]
  $revers^o$ $x^0$ $y^1$ =
    ($x^0$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ []) $\vee$ |\label{line:reversoIOANNfail2}|
    (fresh [h, t, r] (
        $x^0$ $\equiv$ $h^1$ : $t^1$ $\wedge$ |\label{line:reversoIOANNfail4}|
        $append^o$ $r^{2}$ $[h^1]$ $y^{2}$ |\label{line:reversoIOANNfail5}|
        $revers^o$ $t^1$ $r^{2}$ $\wedge$ |\label{line:reversoIOANNfail6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Аннотирование $revers^o$ в прямом направлении с порядком вызовов $append^o$-$revers^o$}
  \label{lst:reversoIOANNfail}
\end{figure}

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.5\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=33, escapechar=|]
  $append^o$ $x^1$ $y^0$ $z^1$ =
    ($x^1$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ $z^0$) $\vee$ |\label{line:appendoOIOANN2}|
    (fresh [h, t, r] (
        $x^{Undef}$ $\equiv$ $h^{Undef}$ : $t^1$ $\wedge$ |\label{line:appendoOIOANNfail4}|
        $z^{Undef}$ $\equiv$ $h^{Undef}$ : $r^1$ $\wedge$ |\label{line:appendoOIOANNfail5}|
        $append^o$ $t^1$ $y^0$ $r^1$ |\label{line:appendoOIOANNfail6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Аннотирование $append^o$ со вторым входным аргументом}
  \label{lst:appendoOIOANNfail}
\end{figure}

Посмотрим, как будет происходить аннотирование, если поменять местами вызовы $append^o$ и $revers^o$~\ref{lst:reversoIOANN}.
Строка~\ref{line:reversoIOANN5} содержит рекурсивный вызов того же направления, что и исходное отношение --- так становится известна переменная $r$.
Аннотирование будет успешно завершено аннотированием вызова $append^o$ в обратном направлении (см. рисунок~\ref{lst:appendoOOIANN})в строке~\ref{line:reversoIOANN6}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=40, escapechar=|]
  $revers^o$ $x^0$ $y^1$ =
    ($x^0$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ []) $\vee$ |\label{line:reversoIOANN2}|
    (fresh [h, t, r] (
        $x^0$ $\equiv$ $h^1$ : $t^1$ $\wedge$ |\label{line:reversoIOANN4}|
        $revers^o$ $t^4$ $r^3$ $\wedge$ |\label{line:reversoIOANN5}|
        $append^o$ $r^3$ $[h^2]$ $y^0$ |\label{line:reversoIOANN6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Аннотирование $revers^o$ в прямом направлении с порядком вызовов $revers^o$-$append^o$}
  \label{lst:reversoIOANN}
\end{figure}

Таким образом, для решения проблемы нескольких вызовов в одном дизъюнкте было предложено решение с перестановками конъюнктов.
Если в аннотируемом отношении в одном дизъюнкте найдено несколько вызовов, создаётся несколько версий этого дизъюнкта.
Каждая версия отличается очередной перестановкой вызовов.
Далее будем запускать аннотирование дизъюнкта на каждой из версий до тех пор, пока либо аннотирование закончится успехом, либо переберём все возможные версии.
В последнем случае считается, что аннотирование неуспешно.

\subsubsection{Унификация fresh-переменных только друг с другом}

Причина, по которой невозможно проаннотировать $append^o$ со вторым входным аргументом (см. рисунок~\ref{lst:appendoOIOANNfail}) --- fresh-переменные, которые зависят только друг от друга.
В данном примере это переменные $h$, $x$ и $z$.
$h$ встречается в двух унификациях, но проаннотировать её невозможно.
В строке~\ref{line:appendoOIOANNfail4} она унифицируется с переменной $x$, а в строке~\ref{line:appendoOIOANNfail5} --- с переменной $z$.
$x$, и $z$ являются выходными (fresh-переменными) и их значения остаются неизвестными, так как они не присутствуют в последнем конъюнкте (строка~\ref{line:appendoOIOANNfail6}).

Таким образом, не существует возможности проаннотировать fresh-переменные, зависящие друг от друга, так как они никогда не станут известны --- остаются свободными.
В \miniKanren{} такие переменные могут принимать все допустимые значения.
Мы можем сымитировать данный подход, добавив генерацию переменных оставшихся свободными.
Под \emph{добавлением генерации} понимается добавление в дизъюнкт нового конъюнкта --- унификации целевой переменной со списком всех допустимых значений.
В этом случае аннотация такой переменной будет являться аннотацией константы и равна $1$.

Рассмотрим полный алгоритм добавления генерации.
Прежде всего, необходимо произвести аннотирование отношения без генерации по вышеописанному алгоритму, чтобы выяснить, какие переменные не получилось проаннотировать.
Если полученный после аннотирования стек содержит частично проаннотированные определения, проанализируем каждое из них.
Рассмотрим каждую унификацию.
Если она содержит непроаннотированные переменные, то содержит их в обеих частях.
Нет смысла генерировать переменные обеих частей: переменные одной части станут известны, если станут известны переменные другой.
Поймём, какая из частей унификации является подвыражением другой и будем генерировать переменные части-подвыражения.

После добавления генерации необходимо запустить алгоритм аннотирования ещё раз, чтобы проаннотировать сгенерированные переменные и распространить их аннотации на всё отношение.
Шаг "генерация-аннотация" нужно повторять до достижения неподвижной точки: после генерации при повторном аннотировании может появиться возможность проаннотировать вызов, который до этого был на полностью неопределённых переменных.
Для аннотирования тела этого вызова так же может потребоваться генерация.
Аннотирование $append^o$ со вторым входным аргументом с добавлением генерации приведено на рисунке~\ref{lst:appendoOIO}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=33, escapechar=|]
  $append^o$ $x^1$ $y^0$ $z^1$ =
    ($x^1$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ $z^0$) $\vee$ |\label{line:appendoOIOANN2}|
    (fresh [h, t, r] (
        $h^1$ $\equiv$ $<gen:>$ $\wedge$ |\label{line:appendoOIOANN4}|
        $x^2$ $\equiv$ $h^1$ : $t^1$ $\wedge$ |\label{line:appendoOIOANN5}|
        $z^2$ $\equiv$ $h^1$ : $r^1$ $\wedge$ |\label{line:appendoOIOANN6}|
        $append^o$ $t^1$ $y^0$ $r^1$ |\label{line:appendoOIOANN7}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Аннотирование $append^o$ со вторым входным аргументом c добавлением генерации}
  \label{lst:appendoOIOANN}
\end{figure}

Генерация позволила проаннотировать $append^o$ со вторым входным аргументом. 
В этом случае аннотирование $revers^o$ с последовательностью вызовов $append^o$-$revers^o$ (рисунок~\ref{lst:reversoIOANNfail}) становится успешным.
Это даёт два способа трансляции $revers^o$ в прямом направлении.
Для примера на рисунке~\ref{lst:reversoIOANNfail} из вызовов будут сгенерированны две функции: предикат $revers^o$ и $append^o$ со вторым входным аргументом.
Для примера на рисунке~\ref{lst:reversoIOANN}) --- только $append^o$ в обратном направлении.

Генерация переменных способна влиять на направления вычислений конъюнктов, поэтому её стоит применять только по необходимости.
Чтобы нивелировать это влияние, будем генерировать переменные только в случае не успешного аннотирования.
Для этого поместим алгоритм генерации после алгоритма перебора перестановок конъюнктов.
На примере $revers^o$: из двух вариантов предпочтительной последовательностью конъюнктов обладает вариант на рисунке~\ref{lst:reversoIOANN}.
Аннотирование второго дизъюнкта на рисунке~\ref{lst:reversoIOANNfail} завершится неудачей, поэтому произойдёт перестановка вызовов и получим последовательность конъюнктов другого варианта.
Это приведёт к успеху аннотирования и генерация не понадобится.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Нерекурсивные вызовы на конструкторах}

К моменту вызова аргумент-конструктор может быть проаннотирован частично.
В этом случае неизвестно является ли переменная, соответствующая данному аргументу, входной или выходной.
Другими словами, невозможно определить направление вызова.

Для решения данной проблемы будем действовать следующим образом:
\begin{itemize}
    \item Сформируем новое отношение, принимающее на вход все переменные аргументов вызова. Его тело --- тело вызываемого отношения с подставленными в него аргументами.
    \item Вызов старого отношения на аргументах-конструкторах заменим на вызов нового отношения на аргументах-переменных. 
\end{itemize}

Рассмотрим пример.
Пусть существует вызов на аргументе конструкторе $append^o~(a : as)~ys~z$.
Сформируем новое отношение $append^o1$ (см. рисунок ~\ref{lst:appendo1}), осуществив подстановку $x~\rightarrow~(a~:~as)$ в тело $append^o$.
Заметим, что первый дизъюнкт $append^o$ отсутствует в $append^o1$.
Он стал заведомо ошибочен: унификация $x \equiv []$ обратилась в $(a : as) \equiv []$.
Во втором дизъюнкте первый конъюнкт обратился в унификацию двух конструкторов и, как следствие, разбился на две унификации.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=41, escapechar=|]
  $append^o1$ $a$ $as$ $y$ $z$ =
    (fresh [h, t, r] (
        a $\equiv$ h $\wedge$ |\label{line:appendo13}|
        as $\equiv$ t $\wedge$ |\label{line:appendo14}|
        z $\equiv$ h : r $\wedge$ |\label{line:appendo15}|
        $append^o$ t y r |\label{line:appendo16}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{$append^o1$, полученное подстановкой $x~\rightarrow~(a~:~as)$ в $append^o$}
  \label{lst:appendo1}
\end{figure}

Производить замену вызова на аргументах-конструкторах нужно так же в теле созданного отношения, поэтому данный алгоритм должен запускаться до достижения неподвижной точки.
В связи с этим алгоритм может зацикливаться при работе с рекурсивными вызовами на конструкторах.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Рекурсивные вызовы на конструкторах}

Рассмотрим проблему на примере.
Отношение $revacc^o$ связывает три переменные: третья получается переворачиванием первой, а вторая является аккумулятором.
$revacc^o$ приведено на рисунке~\ref{lst:revacco}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=48, escapechar=|]
  $revacc^o$ $xs$ $acc$ $sx$ =
    ($xs$ $\equiv$ [] $\wedge$ $sx$ $\equiv$ $acc$) $\vee$ |\label{line:revacco2}|
    (fresh [h, t] (
        $xs$ $\equiv$ $h$ : $t$ $\wedge$ |\label{line:revacco4}|
        $revacc^o$ $t$ $(h~\%~acc)$ $sx$ |\label{line:revacco5}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Отношение $revacc^o$}
  \label{lst:revacco}
\end{figure}

Данное отношение содержит рекурсивный вызов на конструкторе в строке~\ref{line:revacco5}.
Попробуем заменить его на новое отношение по алгоритму, описанному в предыдущей секции.
Подстановка $aсс~\rightarrow~(h~:~acc)$ в $revacc^o$ представлена на рисунке~\ref{lst:revacco1}.
На данном рисунке видно, что в строке~\ref{line:revacco15} такая подстановка привела к большей вложенности конструкторов.
Это означает, что неподвижная точка не будет достигнута никогда.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=48, escapechar=|]
  $revacc^o1$ $xs$ $h$ $acc$ $sx$ =
    ($xs$ $\equiv$ [] $\wedge$ $sx$ $\equiv$ $(h~\%~acc)$) $\vee$ |\label{line:revacco12}|
    (fresh [h', t] (
        $xs$ $\equiv$ $h'$ : $t$ $\wedge$ |\label{line:revacco14}|
        $revacc^o$ $t$ $(h'~\%~(h~\%~acc))$ $sx$ |\label{line:revacco15}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{$revacc^o1$, полученное подстановкой $acc~\rightarrow~(h~:~acc)$ в $revacc^o$}
  \label{lst:revacco1}
\end{figure}

Альтернативное решение состоит из двух шагов:
\begin{itemize}
    \item В дизъюнкт, содержащий рекурсивный вызов на конструкторе, добавим конъюнкт --- унификацию этого конструктора с новой переменной;
    \item В вызове аргумент-конструктор заменим на новую переменную; 
\end{itemize}

На рисунке~\ref{lst:revacco2IOOANN} приведён пример применения данного решения и аннотирование $revacc^o$ с первым входным аргументом.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=48, escapechar=|]
  $revacc^o2$ $xs0$ $acc1$ $sx1$ =
    ($xs0$ $\equiv$ [] $\wedge$
    $sx1$ $\equiv$ $<gen:>$ $\wedge$|\label{line:revacco2IOOANN2}|
    $sx1$ $\equiv$ $acc2$) $\vee$ |\label{line:revacco2IOOANN3}|
    (fresh [h, t, hacc] (
        $xs0$ $\equiv$ $h1$ : $t1$ $\wedge$ |\label{line:revacco2IOOANN5}|
        $hacc2$ $\equiv$ $h1$ : $acc3$ $\wedge$ |\label{line:revacco2IOOANN6}|
        $revacc^o$ $t1$ $hacc2$ $sx2$ |\label{line:revacco2IOOANN7}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{$Аннотирование revacc^o$, полученное унификацией аргумента-конструктора, с первым входным аргументом}
  \label{lst:revacco2IOOANN}
\end{figure}

Унификация позволит определять к моменту вызова, является ли аргумент, бывший конструктором, входным или выходным.
Однако, так может потеряться информация об аннотации переменных, входящих в состав аргумента-конструктора.
Это может препятствовать успешному аннотированию.
Применение генерации поможет с этим справиться. 

Данный подход может работать и для нерекурсивных вызовов на конструкторах, но он с большей вероятностью потребует генерацию, применение которой хочется избежать.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Вызовы на одних и тех же переменных}

Вызовы отношений могут происходить на одних и тех же переменных.
В этом случае аннотации соответствующих аргументов обязаны совпадать.
Это делает не валидными некоторые направления, которые, судя по количеству аргументов, должны существовать.

Рассмотрим пример: $append^o~x~x~z$.
У $append^o$ три аргумента и, значит, восемь направлений.
Однако, первые два аргумента данного вызова совпадают и направлений остаётся четыре, так как направления с разной аннотацией первых двух аргументов становятся невалидными.

Справиться с данной проблемой помогает тот же подход, что и для нерекурсивных вызовах на конструкторах: создадим новое отношение, подставив аргументы в тело исходного.
В созданном отношении (см. рисунок~\ref{lst:appendo2}) заведомо не может существовать невалидных направлений.
\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=57, escapechar=|]
  $append^o2$ x z =
    (x $\equiv$ [] $\wedge$ x $\equiv$ z) $\vee$ |\label{line:appendo22}|
    (fresh [h, t, r] (
        x $\equiv$ h : t $\wedge$ |\label{line:appendo24}|
        z $\equiv$ h : r $\wedge$ |\label{line:appendo25}|
        $append^o$ t x r |\label{line:appendo26}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{$append^o2$, полученное подстановкой $y~\rightarrow~x$ в $append^o$}
  \label{lst:appendo2}
\end{figure}
