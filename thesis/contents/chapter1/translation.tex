\subsection{Трансляция в функциональный язык}

Суть трансляции:
\emph{По отношению с фиксированным направлением генерируется функция на функциональном языке программирования}.

Утверждается, что транслированная версия отношения будет выполняться быстрее, чем оригинальная в направлении трансляции.
Преимущество заключается уже в том, что встраиваемый \miniKanren{} имеет затраты на интерпретацию в хостовый язык, в то время как транслированная версия будет выполняться на хостовом языке сразу же.

\subsubsection{Альтернативные подходы к ускорению программ}

В~\cite{lozov2019relational} для решения этой проблемы используется специализация. 
В статье показано, что специализация приводит к существенному приросту скорости работы программы.
Однако, чтобы избавиться от всех накладных расходов, связанных с интерпретацией программы, необходим Джонс-оптимальный специализатор~\cite{jones1993partial}, реализация которого --- нетривиальная задача.
Трансляция позволяет избежать затрат на интерпретацию.

\subsubsection{Основная проблема трансляции}

Особенностью реляционного программирования является отсутствие строго порядка исполнения программы: он может отличаться для разных направлений.
Это затрудняет трансляцию в функциональные языки программирования.
Для успешной трансляции необходимо определить направления унификаций и вызовов отношений, а так же их порядок исполнения с учётом направления трансляции. 
Для решения такой задачи используется \textit{анализ времени связывания} (binding time analysis). 

Отношение, выполненное в заданном направлении, можно рассматривать как функцию из известных аргументов в неизвестные. 
Например, отношение $append^o$, выполненное в прямом направлении ($append^o \ x \ y \ ?$), соответствует функции конкатенации списков $x$ и $y$. 

Отношение $append^o$ состоит из двух дизъюнктов. 
Первый дизъюнкт означает, что если $x$ является пустым списком, то $y$ совпадает с $z$. 
Второй дизъюнкт означает, что $x$ и $z$ являются списками, начинающимися с одного и того же элемента, при этом хвостом $z$ является результат конкатенации хвоста списка $x$ со списком $y$. 
Унификация с участием неизвестной переменной $z$ указывает на то, \emph{как} вычислить её значение, в то время как унификация известной переменной $x$ --- \emph{при каком условии}.

Автоматическая трансляция $append^o$ в прямом направлении создаст функцию, приведенную на листинге~\ref{lst:appendoFWD}. 
В двух уравнениях первая переменная сопоставляется с образцом. 
В первом случае мы сразу возвращаем второй список как результат, в то время как во втором необходимо осуществить рекурсивный вызов построенной функции. 

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.7\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=8, escapechar=|]
        appendoIIO x0 x1 = appendoIIO0 x0 x1 ++ appendoIIO1 x0 x1
        appendoIIO0 s3$@$[] s0 = do                                  |\label{line:appendoIIOTR2}|
          let s4 = s0
          return $\$$ (s4)
        appendoIIO0 _ _ = []                                         |\label{line:appendoIIOTR5}|
        appendoIIO1 s3$@$(s5 : s6) s0 = do                           |\label{line:appendoIIOTR6}|
          (s7) <- appendoIIO s6 s0
          let s4 = (s5 : s7)
          return $\$$ (s4)
        appendoIIO1 _ _ = []                                         |\label{line:appendoIIOTR10}|
  \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат трансляции $append^o \ x \ y \ ?$}
  \label{lst:appendoFWD}
\end{figure}

Пример трансляции $append^o \ ? \ ? \ z$ приведен в листинге~\ref{lst:appendoBWD}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.7\textwidth}
    \begin{lstlisting}[language=Haskell, frame=single, numbers=left, numberstyle=\small, firstnumber=13, escapechar=|]
        appendoOOI x0 = appendoOOI0 x0 ++ appendoOOI1 x0 |\label{line:appendoOOITR1}|
        appendoOOI0 s4$@$s0 = do                         |\label{line:appendoOOITR2}|
          let s3 = []                                    |\label{line:appendoOOITR3}|
          return $\$$ (s3, s0)                           |\label{line:appendoOOITR4}|
        appendoOOI0 _ = []                               |\label{line:appendoOOITR5}|
        appendoOOI1 s4$@$(s5 : s7) = do                  |\label{line:appendoOOITR6}|
          (s6, s0) <- appendoOOI s7                      |\label{line:appendoOOITR7}|
          let s3 = (s5 : s6)                             |\label{line:appendoOOITR8}|
          return $\$$ (s3, s0)                           |\label{line:appendoOOITR9}|
        appendoOOI1 _ = []                               |\label{line:appendoOOITR10}|
      \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат трансляции $append^o \ ? \ ? \ z$ }
  \label{lst:appendoBWD}
\end{figure}

Нетрудно заметить, что порядок вычислений в функциях нередко не совпадает с порядком конъюнктов в исходном отношении. 
Например, рекурсивный вызов отношения $append^o$ производится в последнем конъюнкте (см. рис.~\ref{lst:appendoDEF}, строка~\ref{line:ma6}), в то время как в функциях выполняется в первую очередь.

\subsubsection{Обзор существующих решений}

Существуют трансляторы логических программ, но все они обладают спецификой \prolog{} или стараются сохранить полимодальность при трансляции.
Так, в~\cite{Matsushita1997FCO} обсуждается проблема трансляции $cut$-операции.
\cite{Bellia1986TRB} рассматривают способы интеграции логического и функционального программирования.
Демонстрируется невозможность трансляции унификации в сопоставление с образцом по причине возможности унификации вычисляться в различных направлениях.
В случае транслятора, предлагаемого в данной работе, направление быть должно и вышеупомянутой проблемы нет.
Ту же проблему имеет \cite{marchiori1995the} --- попытка сохранить полимодальность при трансляции.
