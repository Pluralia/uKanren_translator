\subsection{Тестирование}

Данная часть описывает способ тестирования разработанного алгоритма трансляции.

Он принимает на вход программу в абстрактном синтаксисе \miniKanren{} и выдаёт программу в абстрактном синтаксисе функционального языка.
Такой результат алгоритма невозможно запустить.
В то же время наилучшим способом тестирования является именно запуск полученной функции.
Это влечёт за собой необходимость создать транслятор абстрактного синтаксиса функционального языка в конкретный.
Кроме того, работать с \miniKanren{} в абстрактном синтаксисе так же не очень удобно.
В связи с чем разработан простейший конкретный синтаксис \miniKanren{} и реализован его парсер.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Парсер конкретного синтаксиса \miniKanren{}}

\miniKanren{} --- встраиваемый язык и это одно из его преимуществ, поэтому при разработке конкретного синтаксиса не стояло цели создать идеальный.
Цель его создания --- удобства тестирования.

Была создана соответствующая грамматика (см. приложение) и написан парсер на \haskell{}.

Пример конкретного синтаксиса приведён на рисунке~\ref{lst:ex}.
В строке~\ref{line:ex1} присутствует слово $conde$ --- оно является синтаксическим сахаром для дизъюнкции нескольких дизъюнктов.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=1, escapechar=|]
    $::$ $append^o$ x y xy = conde |\label{line:ex1}|
      (x === [] /\ xy === y)
      ([h t r: 
          x === h $\%$ t /\
          xy === h $\%$ r /\
          {appendo t y r}])     
  \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Пример конкретного синтаксиса \miniKanren{}}
  \label{lst:ex}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Транслятор абстрактного синтаксиса функционального языка в конкретный}

Алгоритм трансляции абстрактного синтаксиса функционального языка в конкретный тривиален.
Он представляет собой последовательный обход всех конструкций абстрактного синтаксиса функционального языка и печать их форме, соответствующей конкретному синтаксису \haskell{}.

Заметим, что можно выбрать конкретный синтаксис любого другого функционального языка программирования.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Система тестирования}

Для тестиравания была создана база программ на \miniKanren{}, покрывающая все варианты классификаций.
Само тестирование выглядит так:
\begin{itemize}
    \item Запуск парсера на программа в конкретном синтаксисе \miniKanren{};
    \item Трансляция в абстрактный функцильнаый синтаксис;
    \item Трансляция в \haskell{};
    \item Запуск $unit$-тестов на транслированной \haskell{}-программе с целью проверить, что программа обладает желаемым поведением.
\end{itemize}

По результатам $unit$-тестирования можно утверждать, что данный алгоритм работает для всех выделенных типов программ \miniKanren{}; ограничением трансляции является невозможность трансляции отношений на направлении, когда все аргументы являются выходными.