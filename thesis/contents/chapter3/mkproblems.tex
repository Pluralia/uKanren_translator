\subsection{Особенности \miniKanren{} и способы их трансляции}

\miniKanren является реляционным языком программирования, а то время как трансляция осуществляется в функциональный.
Данный раздел рассматривает особенности \miniKanren{} и способы их поддержания в функциональном языке.
Так как для тестирования абстрактный синтаксис функционального языка транслируется в конкретный синтаксис \haskell{}, описания решения проблем будут в терминах конструкций \haskell{}.
Однако, это не умаляет общности получаемого транслятора.
Используемые конструкции имеют аналоги в любом функциональном языке программирования, и можно написать транслятор абстрактного синтаксиса в любой конкретный.

Все рассматриваемые в данном разделе примеры являются результатом трансляции отношения $append^o$ в различных направлениях.
Само отношение $append^o$ на \miniKanren{} представлено на рисунке~\ref{lst:appendoOOIANN}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=8, escapechar=|]
  $append^o$ $x^1$ $y^1$ $z^0$ =
    ($x^1$ $\equiv$ [] $\wedge$               |\label{line:appendoOOIANN2}|
     $y^1$ $\equiv$ $z^0$) $\vee$             |\label{line:appendoOOIANN3}|
    (fresh [h, t, r] (
        $x^3$ $\equiv$ $h^1$ : $t^2$ $\wedge$ |\label{line:appendoOOIANN4}|
        $z^0$ $\equiv$ $h^1$ : $r^1$ $\wedge$ |\label{line:appendoOOIANN5}|
        $append^o$ $t^2$ $y^2$ $r^1$          |\label{line:appendoOOIANN6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Проаннотированное в обратном направлении отношение $append^o$}
  \label{lst:appendoOOIANN}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Несколько выходных переменных}

Не всегда результатом выполнения отношения является единственный ответ.
Например, при выполнении отношения $append^o$ в обратном направлении, \miniKanren{} вычислит \emph{все} возможные \emph{пары} списков, дающие при конкатенации~$z$.

В~общем случае отношению $R \subseteq X_0 \times \dots \times X_n$, с известными аргументами $X_{i_0}, \dots X_{i_k}$, и неизвестными $X_{j_0}, \dots X_{j_l}$, соответствует функция, возвращающая список результатов $F : X_{i_0} \to \dots \to X_{i_k} \to [X_{j_0} \times \dots \times X_{j_l}]$. 

В качестве решения проблемы предлагается использовать кортежи.
Пример трансляции $append^o$ в обратном направлении приведён на рисунке~\ref{lst:appendoOOITR}.
$OOI$ рядом с названием функции обозначает направление трансляции отношения.
Так, $O$ --- output и $I$ --- input.
Пример получения кортежа в качестве результата находится в строке~\ref{line:appendoOOITR7}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.7\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=1, escapechar=|]
    appendoOOI x0 = appendoOOI0 x0 ++ appendoOOI1 x0 |\label{line:appendoOOITR1}|
    appendoOOI0 s4$@$s0 = do                         |\label{line:appendoOOITR2}|
      let s3 = []                                    |\label{line:appendoOOITR3}|
      return $\$$ (s3, s0)                           |\label{line:appendoOOITR4}|
    appendoOOI0 _ = []                               |\label{line:appendoOOITR5}|
    appendoOOI1 s4$@$(s5 : s7) = do                  |\label{line:appendoOOITR6}|
      (s6, s0) <- appendoOOI s7                      |\label{line:appendoOOITR7}|
      let s3 = (s5 : s6)                             |\label{line:appendoOOITR8}|
      return $\$$ (s3, s0)                           |\label{line:appendoOOITR9}|
    appendoOOI1 _ = []                               |\label{line:appendoOOITR10}|
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Трансляция $append^o$ в обратном направлении}
  \label{lst:appendoOOITR}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Перекрытие результатов дизъюнктов}

Дизъюнкты в программе на \miniKanren{} независимы, то есть все ответы из каждого дизъюнкта объединяются для получения результата выполнения отношения.
Чтобы поддержать данную особенность, будем транслировать каждый дизъюнкт во вспомогательную функцию.
Самому отношению будет соответствовать функция, конкатенирующая результаты этих вспомогательных функций.
Стоит обратить внимание, что рекурсивно вызывается функция $appendoOOI$, построенная по всему отношению, а не какие-либо вспомогательные функции.

Примером такого поведения и соответствующей трансляции является $append^o$ в обратном направлении (см. рисунок~\ref{lst:appendoOOITR}.
Здесь $appendoOOI$ является основной функцией, объединяющей результаты вспомогательных функций $appendoOOI0$ и $appendoOOI1$.
Если запустить $appendoOOI$ на списке из трёх элементов $[1,~2,~3]$, можно получить список всех пар списков, конкатенация которых даёт входящий список: \\ $[([],~[1,~2,~3]),~([1],~[2,~3]),~([1,~2],~[3]),~([1,~2,~3],~[])]$.
Анализируя этот ответ легко понять, что первый кортеж получен из первого дизъюнкта (функции $appendoOOI0$), а все последующие --- из второго (функции $appendoOOI1$).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Недетерминированность результатов}

\miniKanren{} способен выдавать несколько вариантов одной переменной в качестве результата, создавая недетерминированность.
Монада списка --- способ поддержать недетерминированность в функциональном языке.
Используем её в трансляции.
Кроме того, в \haskell{} для неё есть удобная нотация, называемая \emph{do-нотацией}\footnote{Описание do-нотации языка \haskell{}: \url{https://en.wikibooks.org/wiki/Haskell/do\_notation}, дата последнего посещения: 14.05.2020}.

Её применение так же можно видеть на примере трансляции $append^o$ в обратном направлении, представленном на рисунке~\ref{lst:appendoOOITR}.
Связывание в строке~\ref{line:appendoOOITR7} означает, что результат будет вычислен для каждого элемента списка, полученного из рекурсивного вызова функции.
Унификации неизвестных переменных (например $x~\equiv~[]$ и $x~\equiv~h~\%~t$) при трансляции преобразуются в $let$-связывания (строки~\ref{line:appendoOOITR3} и~\ref{line:appendoOOITR8}). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Порядок и направление при исполнении отношений}

Самая главная особенность --- порядок и направление исполнения отношений внутри целевого может отличается для разных направлений.
Данная проблема была указана во введении как мотивация к разработке алгоритма аннотирования переменных.
Адаптация анализа времени связывания к \miniKanren{} и есть решение данной проблемы.
Разработке соответствующего алгоритма была посвящена вся предыдущая глава.
В данном разделе рассмотрим конкретный пример, как аннотации переменных помогают выбрать порядок и направления вычислений отношений.

Пусть есть проаннотированное в обратном направлении отношение $append^o$ (см. рисунок~\ref{lst:appendoOOIANN}), которое необходимо транслировать.
Результат трансляции есть на рисунке~\ref{lst:appendoOOITR}.

Рассмотрим первый дизъюнкт.
В начале определим направления вычислений каждой из них.
Направление первой из них (в строка~\ref{line:appendoOOIANN2}): $let~x~=~[]$, так как аннотация константы всегда меньше аннотации переменной.
Направление второй --- $let~y~=~z$, потому что аннотация $z$ является $0$ (входная переменная), в то время как $y$ --- $1$.
Таким образом, направление выбирается в соответствии с тем, какой части унификации принадлежит большая аннотация: кто содержит наибольшую, тому будет происходить присваивание.
Теперь определим порядок.
Для этого достаточно отсортировать получившиеся на прошлом шаге определения от меньшего к большему по аннотации определяемой переменной.
В примере аннотации $x$ и $y$ совпадают и равны $1$, поэтому в данном случае нам не важен их порядок.
При трансляции (см. рисунок~\ref{lst:appendoOOITR}) определение $y$ станет частью сопоставления с образцом (о том, как это работает, будет рассказано в следующем разделе) в строке~\ref{line:appendoOOITR2}, а определение $x$ --- строкой~\ref{line:appendoOOITR3}.

Перейдём ко второму дизъюнкту.
Определим направления.
Унификация в строке~\ref{line:appendoOOIANN4} обратится в определение $let~x~=~(h~:~t)$, потому что аннотация $x$ больше обоих аннотаций переменных $h$ и $t$.
Строка~\ref{line:appendoOOIANN5} даст определение $let~(h~:~r)~=~z$.
Направление вызова функции в строке~\ref{line:appendoOOIANN6} также определим по максимальной аннотации аргументов вызова.
В данном случае она равна $2$ и встречается у двух переменных --- $t$ и $y$.
Это означает, что вызов происходит в том же направлении, что и исходное отношение, и направление будет выглядеть так: $(t,~y) \leftarrow append^oOOI~r$.
Сортировка определений позволит получить их следующий порядок: $(h~:~r)$, $(t,~y)$, $x$.
При трансляции они окажется, соответственно, в~\ref{line:appendoOOITR6},~\ref{line:appendoOOITR7}~и~\ref{line:appendoOOITR8} строках.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Переменные, принимающие все возможные значения}

При вычислении отношений в различных направлениях нередко встречается ситуация, когда $fresh$-переменные, унифицирующиеся только друг с другом.
В этом случае они остаются свободными.
В \miniKanren{} такие переменные могут принимать все допустимые значения.

Эта же проблема уже встречалась при реализации алгоритма аннотирования.
В нём она разрешилась добавлением специальной унификации типа $x~\equiv~<gen:>$, где $x$ --- переменная, оставшаяся свободной, а $<gen:>$ --- нотация, позволяющая транслятору понять необходимость генерации.
Таким образом, всё, что остаётся сделать --- правильно раскрыть нотацию и произвести генерацию.

Рассмотрим пример трансляции $append^o$ в направлении с первой входной переменной (см. рисунок~\ref{lst:appendoIOOTR}).
Генерация здесь происходит в строке~\ref{line:appendoIOOTR3} и выглядит как вызов функции, возвращающий список.
Функция $gen$ являющейся функцией класса типов $Generator$.
Её реализация лежит на плечах пользователя: в зависимости от типа переменной она может генерировать списки различных сущностей в различном порядке.
Реализация $Generator$ для списков и целых положительных чисел, а так же сам класс типов $Generator$ представлены на рисунке~\ref{lst:generator}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.7\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=22, escapechar=|]
        appendoIOO x0 = appendoIOO0 x0 ++ appendoIOO1 x0
        appendoIOO0 s0$@$[] = do
          s1 <- (gen)                                    |\label{line:appendoIOOTR3}|
          let s2 = s1                                    
          return $\$$ (s1, s2)
        appendoIOO0 _ = []
        appendoIOO1 s0$@$(s3 : s4) = do
          (s1, s5) <- appendoIOO s4
          let s2 = (s3 : s5)
          return $\$$ (s1, s2)
        appendoIOO1 _ = []
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Трансляция $append^o$ в направлении с первой входной переменной}
  \label{lst:appendoIOOTR}
\end{figure}

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.7\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=11, escapechar=|]
        class Generator a where
          gen :: [a]
        
        instance (Generator a) => Generator [a] where
          gen = [] : do
            xs <- gen
            x <- gen
            return (x : xs)
        
        instance Generator Int where
          gen = [0..]
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Класс типов $Generator$ и его реализация для списков и целых чисел}
  \label{lst:generator}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Цикл только за счёт рекурсии}

Данная особенность присуща и функциональной парадигме, поэтому проблем при трансляции с ней нет.
Тем не менее, о ней стоило вспомнить для полноты обсуждения.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
