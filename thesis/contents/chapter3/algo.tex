\subsection{Алгоритм трансляции}

Данный раздел посвящен самому алгоритму трансляции.
Первая часть вводит абстрактный синтаксис в соответствии со всеми особенностями, затронутыми в двух предыдущих разделах.
Вторая часть приводит общий алгоритм трансляции программы в абстрактном синтаксисе \miniKanren{} в программу в абстрактном синтаксисе функционального языка.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Абстрактный синтаксис функционального языка}

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.7\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=30, escapechar=|]
        data Atom = Var String
                  $|$ Ctor String [Atom]
                  $|$ Tuple [String]
        
        data Expr = Term Atom
                  $|$ Call String [Atom]
        
        data Assign = Assign Atom Expr
        
        newtype Guard = Guard [Atom]
        
        data Pat = Pat (Maybe String) Atom
        
        data Line = Line [Pat] [Guard] [Assign] [Guard] Expr
        
        data F = F String [Line]
        
        newtype FuncProgram = FuncProgram [F]
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Абстрактный синтаксис функционального языка}
  \label{lst:funcast}
\end{figure}

Транслированная программа $FuncProgram$ представляет собой множество функций $F$.

Каждая функция $F$ определяется именем и списком вспомогательных функций $Line$.

Каждая вспомогательная функция $Line$ состоит из списка сопоставлений с образцом $Pat$ (представляющего собой список аргументов), списка охранных выражений $Guard$ для сопоставления с образцом, списка определений $Assign$, списка охранных выражений $Guard$ для определений и значения выражения.

Сопоставление с образцом $Pat$ состоит из опционального псевдонима и тела сопоставления с образцом, называемого в данном случае $Atom$.

$Atom$ является аналогом $Term$ из \miniKanren{} с небольшим расширением.
$Atom$ может быть переменной или конструктором, однако, ещё он может быть кортежем (конструктор $Tuple$).
Кореж --- список переменных без конструктора.
Используется, когда необходимо вернуть несколько переменных после вызова функции.

Охранное выражение $Guard$ --- список $Atom$, которые необходимо проверить друг с другом на равенство.

Определение $Assign$ представляет собой $Atom$ и $Expr$ --- значение выражения $Expr$ будет сопоставлено $Atom$.

Выражение $Expr$ может быть или тоже $Atom$, или вызовом функции на списке $Atom$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Алгоритм трансляции}

Первым шагом алгоритма трансляции, безусловно, будет запуск алгоритма аннотирования со всеми нормализациями.
Таким образом, из произвольной программы на \miniKanren{} будет получен стек всех вызовов этой программы, каждый вызов в котором --- нормализованное проаннотированное в определённом направлении определение на \miniKanren{}.

Далее для каждого дизъюнкта каждого определения со стека вызовов запускается сам алгоритм трансляции.
В первом приближении он состоит из следующих шагов:
\begin{itemize}
    \item Формирование списков входных и выходных переменных $in$ и $out$;
    \item Разбиение конъюнктов на те, которые могут стать сопоставлениями с образцом и все остальные;
    \item Удаление перекрытий имён в сопоставлении с образцом путём формирования охранных выражений;
    \item Получение направлений конъюнктов;
    \item Получение порядка определений;
    \item Удаление перекрытий имён в определениях путём формирования условий для ветвления;
\end{itemize}

Множество из этих шагов должны быть очевидны из рассмотренных в предыдущих разделах особоенностей \miniKanren{} и трансляции.
Подробнее рассмотрим только два шага --- получение направлений конъюнктов и получение порядка определений.

Получение направлений конъюнктов происходит по-разному для унификаций и вызовов.
Если конъюнкт --- унификация, определим значение максимальной аннотации в каждой из её частей.
Теперь возможны три случая:
\begin{itemize}
    \item Если эти значения равны, то унификация становится условием ветвления;
    \item Если значение левой части больше, то унификация превращается в определение, где левая часть зависит от правой; в ответ сохраняем не только получившееся определение, но и максимальную аннотацию левой части --- это необходимо для получения порядка вычисления определений;
    \item Оставшийся случай симметричен;
\end{itemize}

Если конъюнкт --- вызов отношения, определим его выходные переменные.
Для этого достаточно узнать максимальную аннотацию его аргументов --- переменные обладающие таковой, стали известны после выполнения вызова и являются зависимыми.
Так же, как делали для унификаций, сохраним значение максимальной аннотации.

Получим порядок определений.
Для этого отсортируем их по максимальной аннотации их зависимой части.
