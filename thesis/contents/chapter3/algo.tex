\subsection{Алгоритм трансляции}

Данная часть приводит общий алгоритм трансляции программы в абстрактном синтаксисе \miniKanren{} в программу в абстрактном синтаксисе функционального языка.

Первым шагом алгоритма трансляции является запуск алгоритма аннотирования, в процессе которого будут произведено приведение программы к нормальной форме.
Таким образом, из произвольной программы на \miniKanren{} будет получен стек всех вызовов этой программы, каждый вызов в котором --- нормализованное проаннотированное в определённом направлении определение на \miniKanren{}.

Далее для каждого дизъюнкта каждого определения со стека вызовов запускается сам алгоритм трансляции.
В первом приближении он состоит из следующих шагов:
\begin{itemize}
    \item Формирование списков входных и выходных переменных $in$ и $out$;
    \item Разбиение конъюнктов на те, которые могут стать сопоставлениями с образцом и все остальные;
    \item Удаление перекрытий имён в сопоставлении с образцом путём формирования охранных выражений;
    \item Определение направлений конъюнктов;
    \item Определение порядка определений;
    \item Удаление перекрытий имён в определениях путём формирования условий для ветвления.
\end{itemize}

Многие из этих шагов были описаны в предыдущих частях об особоенностях \miniKanren{} и построении абстрактного синтаксического дерева функционального языка.
Подробнее рассмотрим только два шага --- получение направлений конъюнктов и получение порядка определений.

Получение направлений конъюнктов происходит по-разному для унификаций и вызовов.
Если конъюнкт --- унификация, определим значение максимальной аннотации в каждой из её частей.
Теперь возможны три случая:
\begin{itemize}
    \item Если эти значения равны, то унификация становится условием ветвления;
    \item Если значение левой части больше, то унификация превращается в определение, где левая часть зависит от правой; в ответ сохраняем не только получившееся определение, но и максимальную аннотацию левой части --- это необходимо для получения порядка вычисления определений;
    \item Оставшийся случай симметричен;
\end{itemize}

Если конъюнкт --- вызов отношения, определим его выходные переменные.
Для этого достаточно узнать максимальную аннотацию его аргументов --- переменные обладающие таковой, стали известны после выполнения вызова и являются зависимыми.
Также, как делали для унификаций, сохраним значение максимальной аннотации.

Получим порядок определений.
Для этого отсортируем их по максимальной аннотации их зависимой части.
