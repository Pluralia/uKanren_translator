\section*{Введение}

Реляционное программирование --- парадигма, в которой любая программа описывает математическое отношение на её аргументах. 
Имея программу-отношение, можно выполнять запросы: указывая некоторые известные аргументы, получать значения остальных.
Например, $add^o \subseteq Int \times Int \times Int$ описывает отношение, третий аргумент которого является суммой первых двух. 
Рассмотрим возможные направления вычисления этого отношения (здесь и далее искомый аргумент будем обозначать знаком ``$?$'').
Выполнение отношения $add^o  \ x \ y \ ?$ с зафиксированными (входными) первым и вторым аргументом найдет их сумму, а $add^o \ ? \ y \ z$ найдет такие числа, которые в сумме с $y$ дадут $z$. 
Также можно найти одновременно значения нескольких аргументов: $add^o \ ? \ ? \ z$ найдет такие пары чисел, что в сумме они равны $z$, а $add^o \ ? \ ? \ ?$ перечислит все тройки из отношения. 

Таким образом, мы можем говорить о выборе \textit{направления} вычисления. 
Часто при написании программы подразумевается конкретное направление, называемое \textit{прямым} (например, $add^o  \ x \ y \ ?$), все остальные направления обычно называются \textit{обратными}. 
Возможность выполнения в различных направлениях --- основное преимущество реляционного программирования. 
Это своеобразный шаг к декларативности: достаточно написать одну программу для получения множества целевых функций. 

Реляционному программированию родственно логическое, представленное такими языками, как \prolog{} и \mercury{}\footnote{Официальный сайт языка \mercury{}: \url{https://mercurylang.org/}, дата последнего посещения: 14.05.2020}~\cite{SOMOGYI199617}.
Основным представителем парадигмы реляционного программирования является семейство интерпретируемых языков \miniKanren{}\footnote{Официальный сайт языка \miniKanren{}: \url{http://minikanren.org/}, дата последнего посещения: 14.05.2020}.
Языки семейства \miniKanren{} компактны и встраиваются в языки общего назначения, за счёт чего их проще использовать в  проектах. 
Для встраивания достаточно реализовать интерпретатор языка \miniKanren{}: ядро языка, реализованное на \scheme{} занимает не более, чем 40 строк~\cite{hemann2013ukanren}.
Помимо этого, \miniKanren{} реализует полный поиск с особой стратегией, поэтому любая программа, написанная на нем, найдет все существующие ответы, в то время как \prolog{} может никогда не завершить поиск. 
В данной работе в качестве конкретного реляционного языка программирования используется \miniKanren{}.

Возможность выполнения программ на \miniKanren{} в различных направлениях позволяет решать задачи поиска посредством решения задачи распознавания~\cite{lozov2019relational}.
Так, имея интерпретатор языка, можно решать задачу синтеза программ на этом языке по набору тестов~\cite{byrd2017unified}; имея функцию, проверяющую, что некоторая последовательность вершин в графе формирует путь с желаемыми свойствами, получать генератор таких путей и так далее. 
$N$-местную функцию-распознаватель, реализованную на некотором языке программирования, можно автоматически транслировать на \miniKanren{}, получив $N+1$-местное отношение, связывающее аргументы функции с булевым значением~\cite{lozov2019relational} (истина соответствует успешному распознаванию). 
Зафиксировав значение $N+1$-ого булевого аргумента, можно выполнять поиск. 
Ценность такого подхода в его простоте: решение задачи поиска всегда труднее, чем реализация распознавателя. 

К сожалению, выполнение отношения в обратном направлении обычно крайне не эффективно. 
В данной работе представлен подъод улучшения производительности программы в заданном направлении.
Для этого по отношению с фиксированным направлением генерируется функция на функциональном языке.
В качестве конкретного функционального языка выбран \haskell{}.

\subsection*{Кратко о следующих главах}

\begin{itemize}
    \item В Главе \ref{domen} даётся описание реляционного языка программирования \miniKanren{}, формулируется задача трансляции, описывается анализ времени связывания как необходимая составная часть транслятора и даётся обзор существующих решений. В конце главы фомулируется цель данной работы, а также определяются задачи, решаемые в последующих главах.

    \item В главе \ref{annotator} описывается разработка алгоритма аннотирования на основе анализа времени связывания. Вводится понятие нормализованной программы, на которой работает алгоритм аннотирования. Доказывается корректность предложенного алгоритма.
    
    \item Глава \ref{translator} начинается с разбора особенностей трансляции. Далее приводится сам алгоритм трансляции. В конец доказывается корректность предложенного алгоритма.

    \item Глава \ref{test} посвящена анализу результатов работы транслятора. В начале описывается способ его тестирования, включающий в себя написание парсера конкретного синтаксиса \miniKanren{}, а так же транслятор абстрактного функционального языка в конкретный. Затем вводится несколько классификаций программ на \miniKanren{} и анализируются ограничения предложенного алгоритма трансляции.
\end{itemize}

\subsection*{Список терминов и сокращений}

\subsubsection*{Термины}

interleaving
парсер
конъюнкт
дизъюнкт

%Примесь (англ. mix in) -- элемент языка программирования (обычно класс или модуль), реализующий какое-либо четко выделенное поведение. Используется для уточнения поведения других классов, не предназначен для порождения самостоятельно используемых объектов.

\subsubsection*{Сокращения}

АСД -- абстрактное синтаксическое дерево -- в информатике конечное помеченное ориентированное дерево, в котором внутренние вершины сопоставлены (помечены) с операторами языка программирования, а листья -- с соответствующими операндами.

ДНФ -- дизъюнктивная нормальная форма -- булевой логике нормальная форма, в которой булева формула имеет вид дизъюнкции конъюнкций литералов.
