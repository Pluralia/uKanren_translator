\section*{Введение}

Реляционное программирование --- парадигма, в которой любая программа описывает математическое отношение на её аргументах. 
Имея программу-отношение, можно выполнять запросы: указывая некоторые известные аргументы, получать значения остальных.
Например, $add^o \subseteq Int \times Int \times Int$ описывает отношение, третий аргумент которого является суммой первых двух. 
Рассмотрим возможные направления вычисления этого отношения (здесь и далее искомый аргумент будем обозначать знаком ``$?$''):
\begin{itemize}
    \item $add^o  \ x \ y \ ?$ с зафиксированными (входными) первым и вторым аргументом найдет их сумму;
    \item $add^o \ ? \ y \ z$ найдет такие числа, которые в сумме с $y$ дадут $z$;
    \item $add^o \ ? \ ? \ z$ найдет такие пары чисел, что в сумме они равны $z$;
    \item $add^o \ ? \ ? \ ?$ перечислит все тройки из отношения.
\end{itemize}

Таким образом, мы можем говорить о выборе \textit{направления} вычисления. 
Часто при написании программы подразумевается конкретное направление, называемое \textit{прямым} (например, $add^o  \ x \ y \ ?$), все остальные направления обычно называются \textit{обратными}. 
Возможность выполнения в различных направлениях --- основное преимущество реляционного программирования. 
Это своеобразный шаг к декларативности: достаточно написать одну программу для получения множества целевых функций. 

Реляционному программированию родственно логическое, представленное такими языками, как \prolog{} и \mercury{}\footnote{Официальный сайт языка \mercury{}: \url{https://mercurylang.org/}, дата последнего посещения: 14.05.2020}~\cite{SOMOGYI199617}.
Основным представителем парадигмы реляционного программирования является семейство интерпретируемых языков \miniKanren{}\footnote{Официальный сайт языка \miniKanren{}: \url{http://minikanren.org/}, дата последнего посещения: 14.05.2020}.
Языки семейства \miniKanren{} компактны и встраиваются в языки общего назначения, за счёт чего их проще использовать в  проектах. 
Для встраивания достаточно реализовать интерпретатор языка \miniKanren{}: ядро языка, реализованное на \scheme{} занимает не более, чем 40 строк~\cite{hemann2013ukanren}.
Помимо этого, \miniKanren{} реализует полный поиск с особой стратегией, поэтому любая программа, написанная на нем, найдет все существующие ответы, в то время как \prolog{} может никогда не завершить поиск. 
В данной работе в качестве конкретного реляционного языка программирования используется \miniKanren{}.

Возможность выполнения программ на \miniKanren{} в различных направлениях позволяет решать задачи поиска посредством решения задачи распознавания~\cite{lozov2019relational}.
Так, имея интерпретатор языка, можно решать задачу синтеза программ на этом языке по набору тестов~\cite{byrd2017unified}; имея функцию, проверяющую, что некоторая последовательность вершин в графе формирует путь с желаемыми свойствами, получать генератор таких путей и так далее. 
$N$-местную функцию-распознаватель, реализованную на некотором языке программирования, можно автоматически транслировать на \miniKanren{}, получив $N+1$-местное отношение, связывающее аргументы функции с булевым значением~\cite{lozov2019relational} (истина соответствует успешному распознаванию). 
Зафиксировав значение $N+1$-ого булевого аргумента, можно выполнять поиск. 
Ценность такого подхода в его простоте: решение задачи поиска всегда труднее, чем реализация распознавателя. 

Однако, выполнение отношения в обратном направлении обычно крайне не эффективно. 
В~\cite{lozov2019relational} для решения этой проблемы используется специализация. 
В статье показано, что специализация приводит к существенному приросту скорости работы программы.
Но, чтобы избавиться от всех накладных расходов, связанных с интерпретацией программы, необходим Джонс-оптимальный специализатор~\cite{jones1993partial}.
Он существует для \prolog{}~\cite{Leuschel2004SIU}, но не существует для \miniKanren{}.
В данной работе разрабатывается альтернативный подход улучшения производительности программы в заданном направлении --- трансляция.
Его суть --- по отношению с фиксированным направлением генерируется функция на функциональном языке.
В связи со сложностью задачи транслятор, обеспечивающий прирост производительности, не разрабатывается сразу.
Данная работа делает первый шаг к этому --- разрабатывает алгоритм трансляции и проверяет, что транслированные программы корректны.

\subsection*{Кратко о следующих главах}

\begin{itemize}
    \item В главе \ref{goals} приводится цель работы и список необходимых для её достижения задач.

    \item В главе \ref{domen} даётся описание реляционного языка программирования \miniKanren{}, формулируется задача трансляции, описывается анализ времени связывания как необходимая составная часть транслятора и даётся обзор существующих решений. В конце главы фомулируется цель данной работы, а также определяются задачи, решаемые в последующих главах.

    \item Глава \ref{translator} начинается с разбора особенностей трансляции. Далее приводится сам алгоритм трансляции. В конце доказывается сохранение семантики программ при трансляции.

    \item В главе \ref{annotator} описывается разработка алгоритма аннотирования на основе анализа времени связывания. Вводится понятие нормализованной программы. Доказывается корректность предложенного алгоритма.

    \item Глава \ref{test} посвящена тестированию работы алгоритма трансляции. В начале предлагается несколько классификаций программ на \miniKanren{} и анализируются ограничения предложенного алгоритма. Затем описывается система его тестирования.
\end{itemize}

\subsection*{Список терминов и сокращений}

\subsubsection*{Термины}

interleaving
парсер
конъюнкт
дизъюнкт

%Примесь (англ. mix in) -- элемент языка программирования (обычно класс или модуль), реализующий какое-либо четко выделенное поведение. Используется для уточнения поведения других классов, не предназначен для порождения самостоятельно используемых объектов.

\subsubsection*{Сокращения}

АСД -- абстрактное синтаксическое дерево -- в информатике конечное помеченное ориентированное дерево, в котором внутренние вершины сопоставлены (помечены) с операторами языка программирования, а листья -- с соответствующими операндами.

ДНФ -- дизъюнктивная нормальная форма -- булевой логике нормальная форма, в которой булева формула имеет вид дизъюнкции конъюнкций литералов.
