# Алгоритм

## Общее описание
- принимает программу и список input-переменных
- возвращает пару из проаннаториванной нормализованной цели и стека (мапа из названия отношения во множество информации о будущей функции; эта информация включает направление вычисления отношения и цель, размеченную по этому направлению)


## translate
1. Получаем gamma
2. Инициализируем goal
  - снимаем все fresh и переименовываем переменные
  - нормализуем
  - аннотируем инфой об аргументах, а также инфой о константах
3. Запускаем аннотирование (`annotate`)

## annotate / annotateInternal
4. Добавляем к цели пустой стек 
5. До fix point (пара из цели и стека не изменилась с предыдущего вызова) будем вызывать `annotateGoal`

## annotateGoal
6. Последовательно пройдёмся по всем дизъюнктам: `annotateDisj` передаём текущий disj и стек после вычислений всех предыдущих disjs

## annotateDisj
7. То же, что и в `annotateGoal`, но обходим конъюнкты (функция `annotateConj`) - в конце делаем `meetGoal` между всеми конъюнктами

## meetGoal
- принимает список конъюнктов, получаем все-все переменные из них, сортирует, группирует - получаем переменную и её аннотации со всех конъюнктов; для каждой переменной на всех её аннотациях вызываем `meet`

## meet
- одна из переменных Undef - возвращаем другую
- обе чем-то проаннотированы - вовзращаем максимум

## annotateConj
8. на данном этапе цель - это либо унификация, либо инвок; разберём обработку каждого из случаев отдельно

### Унификация
- на термах вызываем `meetTerm`

## meetTerm
- слева undef-переменная - получаем максимальную анноцию правого терма (вызываем `maxAnn`)
- слева аннотированная переменная - увеличим её значение на 1 и проставим везде вместо всех Undef в правом терме (используем функцию `replaceUndef` - она ругается на нарушение монотонности, если у внутри терма нашлась переменная, аннотация которой оказалась больше той, на которую хотим заменить)
- слева и справа кторы - проверяем, что их именна и кол-во аргументов совпадают, затем делаем zip аргументов и вызываем `meetTerm` на каждой паре аргументов
- оставшиеся случаи обрабатываются вызовом `meetTerm` на аргументах в обратном порядке; в конце восстанавливается исходный порядок

## maxAnn
- переменная - очевидно
- конструктор - если есть хотя бы 1 внутренний Undef терм, вернём Undef, иначе вернём максимум из аннотаций

### Инвоки
- существует 3 случая:
1. все термы Undef
  - ничего не делаем (будем ждать следущую итерацию, когда о термах станет известно хоть что-то)
2. такая цель уже есть в стеке (проверяем по имени и маске аннотаций термов - список списков, в котором n-ый список содержит номера переменных, инициализируемых в n-ый момент времени)
  - доопределяем Undef-термы как максимальная аннотация оставшихся термов + 1
  - добавляем в стек инфу о новом направлении (ВАЖНО: в качестве цели здесь кладётся undefined - может вылезти боком), при этом происходит сравнение масками с инфой об уже существующих направлениях: оставляется то направление, которое даёт больше информации о времени инициализации термов (пример: пусть есть маски [[2], [0, 1]] и [[2], [1], [0]]; они не противоречат друг другу и вторая даёт больше информации, поэтому её направление "затрёт" в стеке направление первой).
3. цели в списке не оказалось
  - получаем def по имени (из gamma)
  - по def получаем без фрешей, переименнованную, нормализованную, первично проинициализированную (инфой об аннотациях термов при вызове) цель, список ПЕРЕИМЕННОВЫННЫХ названий ЕЁ входных переменных, а также обновляем стек, складывая туда текущую маску и цель
  - аннотируем полученную цель, вызывая `annotateInternal` - получаем новую цель и новый стек
  - из цели получаем аннотации её аргументов и переносим эти аннотации на термы при инвоке - обновляем инвок
  - в уже изменённый стек по маске изменённых на прошлом шаге термов добавляем полученную цель
